<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Kafka," />










<meta name="description" content="GroupCoordinator 每个kafka server在启动的时候会创建一个GroupCoordinator用于管理group以及consumer的offset fetch/commit  在创建GroupCoordinator实例时不仅需要brokerId、group以及offset config，还需要传入replicaManager，其作用是 GroupMetadataManager">
<meta name="keywords" content="Kafka">
<meta property="og:type" content="article">
<meta property="og:title" content="Kafka Coordinator实现细节">
<meta property="og:url" content="http://yoursite.com/2018/04/04/Kafka-Coordinator实现细节/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="GroupCoordinator 每个kafka server在启动的时候会创建一个GroupCoordinator用于管理group以及consumer的offset fetch/commit  在创建GroupCoordinator实例时不仅需要brokerId、group以及offset config，还需要传入replicaManager，其作用是 GroupMetadataManager">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://olt6kofv9.bkt.clouddn.com/17-5-25/78440956.jpg">
<meta property="og:image" content="http://olt6kofv9.bkt.clouddn.com/17-5-25/33077532.jpg">
<meta property="og:image" content="http://olt6kofv9.bkt.clouddn.com/17-5-25/40124304.jpg">
<meta property="og:image" content="http://olt6kofv9.bkt.clouddn.com/18-3-26/38785112.jpg">
<meta property="og:updated_time" content="2018-04-04T07:30:59.939Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Kafka Coordinator实现细节">
<meta name="twitter:description" content="GroupCoordinator 每个kafka server在启动的时候会创建一个GroupCoordinator用于管理group以及consumer的offset fetch/commit  在创建GroupCoordinator实例时不仅需要brokerId、group以及offset config，还需要传入replicaManager，其作用是 GroupMetadataManager">
<meta name="twitter:image" content="http://olt6kofv9.bkt.clouddn.com/17-5-25/78440956.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/04/04/Kafka-Coordinator实现细节/"/>





  <title>Kafka Coordinator实现细节 | Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/04/Kafka-Coordinator实现细节/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Kafka Coordinator实现细节</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-04T15:29:55+08:00">
                2018-04-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2018/04/04/Kafka-Coordinator实现细节/" class="leancloud_visitors" data-flag-title="Kafka Coordinator实现细节">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="GroupCoordinator"><a href="#GroupCoordinator" class="headerlink" title="GroupCoordinator"></a>GroupCoordinator</h1><blockquote>
<p>每个kafka server在启动的时候会创建一个GroupCoordinator用于管理group以及consumer的offset fetch/commit</p>
</blockquote>
<p>在创建GroupCoordinator实例时不仅需要brokerId、group以及offset config，还需要传入<strong>replicaManager</strong>，其作用是</p>
<h2 id="GroupMetadataManager"><a href="#GroupMetadataManager" class="headerlink" title="GroupMetadataManager"></a>GroupMetadataManager</h2><p>GroupMetadataManager是GroupCoordinator最重要的组成部分，其作用是管理group的元信息(状态、成员、提交的offset信息)以及作为coordinator的broker所分配到的分区信息，主要成员有4个：</p>
<ol>
<li>groupMetadataCache：存储group与GroupMetadata的cache</li>
<li>loadingPartitions：”__consumer_offsets”中正在被当前coordinator加载的分区</li>
<li>ownedPartitions：”__consumer_offsets”中分配到当前coordinator的分区(即该broker是这些分区的leader)</li>
<li>scheduler：删除过期offset以及group元数据的定时任务(执行间隔由<code>offsets.retention.check.interval.ms</code>参数控制，默认为10分钟)</li>
</ol>
<h3 id="consumer-offsets"><a href="#consumer-offsets" class="headerlink" title="__consumer_offsets"></a><strong>__consumer_offsets</strong></h3><p>__consumer_offsets是用于存储消费者消费信息的topic，存储的消息由两部分组成</p>
<ul>
<li><p>一部分是offset信息(<em>kafka.coordinator.OffsetsMessageFormatter</em>类型)的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[groupId,topic,partition]::[OffsetMetadata[offset,metadata],CommitTime ExprirationTime]</span><br></pre></td></tr></table></figure>
</li>
<li><p>另一部分是group信息(<em>kafka.coordinator.GroupMetadataMessageFormatter</em>类型):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupId::[groupId,Some(consumer),groupState,Map(memberId -&gt; [memberId,clientId,clientHost,sessionTimeoutMs], ...-&gt;[]...)]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>group分配到哪个分区的策略在<a href="http://blog.leanote.com/post/zfb050/Kafka-consumer" target="_blank" rel="noopener">kafka cosumer</a>中介绍过了。</p>
<p>作为一个特殊的topic，<strong>consumer_offsets也有replica的概念，<del>并且其replica factor与其他topic保持一致</del>。</strong>consumer_offsets上每个分区都对应一个leader，作为leader的broker上的GroupCoordinator会记录着分区上记录着的group以及offset信息。当leader(__consumer_offsets分布的leader)发生变化时，新的leader需要加载对应分区上的group以及offset信息。</p>
<p>server在处理<code>LeaderAndIsrRequest</code>时会对__consumer_offsets的分区做<em>出入境</em> 操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def onLeadershipChange(updatedLeaders: Iterable[Partition], updatedFollowers: Iterable[Partition]) &#123;</span><br><span class="line">        updatedLeaders.foreach &#123; partition =&gt;</span><br><span class="line">          if (partition.topic == Topic.GroupMetadataTopicName)</span><br><span class="line">            coordinator.handleGroupImmigration(partition.partitionId)</span><br><span class="line">        &#125;</span><br><span class="line">        updatedFollowers.foreach &#123; partition =&gt;</span><br><span class="line">          if (partition.topic == Topic.GroupMetadataTopicName)</span><br><span class="line">            coordinator.handleGroupEmigration(partition.partitionId)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="小实验"><a href="#小实验" class="headerlink" title="小实验"></a><strong>小实验</strong></h4><p>“G3”这个group根据hash映射到分区2上，当前的ISR为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Topic: __consumer_offsets	Partition: 2	Leader: 1	Replicas: 1,3,2	Isr: 2,3,1</span><br></pre></td></tr></table></figure></p>
<p>接下来，关闭broker1，导致broker3成为了新的leader。</p>
<p>broker3执行<em>入境</em> 操作，加载分区2上面的的offset以及group信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Group Metadata Manager]: Loading offsets and group metadata from [__consumer_offsets,2]</span><br><span class="line">[Group Metadata Manager]: Loaded group metadata for group G3 with generation 1</span><br><span class="line">[Group Metadata Manager]: Loaded group metadata for group G3 with generation 2</span><br><span class="line">[Group Metadata Manager]: Loaded group metadata for group G3 with generation 3</span><br><span class="line">[Group Metadata Manager]: Loaded group metadata for group G3 with generation 4</span><br><span class="line">[Group Metadata Manager]: Loaded offset [OffsetMetadata[3448,NO_METADATA],CommitTime 1495503059311,ExpirationTime 1495506659311] for newOne-0.</span><br><span class="line">[Group Metadata Manager]: Loaded offset [OffsetMetadata[3441,NO_METADATA],CommitTime 1495503059311,ExpirationTime 1495506659311] for newOne-3.</span><br><span class="line">[Group Metadata Manager]: Loaded offset [OffsetMetadata[3257,NO_METADATA],CommitTime 1495503059311,ExpirationTime 1495506659311] for newOne-5.</span><br><span class="line">[Group Metadata Manager]: Loaded offset [OffsetMetadata[3382,NO_METADATA],CommitTime 1495503059311,ExpirationTime 1495506659311] for newOne-2.</span><br><span class="line">[Group Metadata Manager]: Loaded offset [OffsetMetadata[3397,NO_METADATA],CommitTime 1495503059311,ExpirationTime 1495506659311] for newOne-4.</span><br><span class="line">[Group Metadata Manager]: Loaded offset [OffsetMetadata[3163,NO_METADATA],CommitTime 1495503059311,ExpirationTime 1495506659311] for newOne-1.</span><br><span class="line">[GroupCoordinator 3]: Loading group metadata for G3 with generation 4</span><br><span class="line">[Group Metadata Manager]: Finished loading offsets from [__consumer_offsets,2] in 21 milliseconds.</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>在<code>loadGroupsForPartition</code>方法中通过使用Map确保加载每个group最新generation的信息</p>
</blockquote>
<p>在执行入境操作之前，分区2被添加到<code>loadingPartitions</code>中，表示coordinator正在加载该分区里面的信息，这个阶段如果有groupId在loadingPartitions之内的消费请求进来，是无法响应的；<br>处理完后，分区2被添加到<code>ownedPartitions</code>中。</p>
<h3 id="保存group元数据"><a href="#保存group元数据" class="headerlink" title="保存group元数据"></a><span id="storeGroup">保存group元数据</span></h3><p>方法定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def prepareStoreGroup(group: GroupMetadata,</span><br><span class="line">                        groupAssignment: Map[String, Array[Byte]],</span><br><span class="line">                        responseCallback: Errors =&gt; Unit): Option[DelayedStore]</span><br></pre></td></tr></table></figure></p>
<ul>
<li>groupAssignment是group中member的分区分配</li>
<li>返回值是<strong>DelayedStore</strong>，这并不是一个<strong>DO</strong>类型的延迟任务，只适用于存放消息的临时媒介，方便后续往replicas中写Log用的。</li>
</ul>
<h4 id="生成消息"><a href="#生成消息" class="headerlink" title="生成消息"></a><strong>生成消息</strong></h4><p>第一步是生成能往Log(<strong>确切的说是写入__consumer_offsets中该group对应的partition中</strong>)中写入的<em>ByteBufferMessageSet</em>(<a href="http://leanote.com/blog/post/58e4bd26ab64413a3300ed80" target="_blank" rel="noopener">消息写入磁盘及备份实现分析</a>),key为groupId,value为member以及sessionTimeout，即上面所说的group信息。</p>
<h4 id="设置appendLog回调函数"><a href="#设置appendLog回调函数" class="headerlink" title="设置appendLog回调函数"></a><strong>设置appendLog回调函数</strong></h4><p>该回调函数作为参数传入到<code>ReplicaManager.replicaMessages</code>，对append操作的结果进行处理，最主要的就是状态的转换：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">case Errors.UNKNOWN_TOPIC_OR_PARTITION</span><br><span class="line">     | Errors.NOT_ENOUGH_REPLICAS</span><br><span class="line">     | Errors.NOT_ENOUGH_REPLICAS_AFTER_APPEND =&gt;</span><br><span class="line">  Errors.GROUP_COORDINATOR_NOT_AVAILABLE</span><br><span class="line"></span><br><span class="line">case Errors.NOT_LEADER_FOR_PARTITION =&gt;</span><br><span class="line">  Errors.NOT_COORDINATOR_FOR_GROUP</span><br><span class="line"></span><br><span class="line">case Errors.REQUEST_TIMED_OUT =&gt;</span><br><span class="line">  Errors.REBALANCE_IN_PROGRESS</span><br><span class="line"></span><br><span class="line">case Errors.MESSAGE_TOO_LARGE</span><br><span class="line">     | Errors.RECORD_LIST_TOO_LARGE</span><br><span class="line">     | Errors.INVALID_FETCH_SIZE =&gt;</span><br><span class="line">  Errors.UNKNOWN</span><br></pre></td></tr></table></figure></p>
<h4 id="执行storeGroup回调函数"><a href="#执行storeGroup回调函数" class="headerlink" title="执行storeGroup回调函数"></a><strong>执行storeGroup回调函数</strong></h4><p>在<code>doSyncGroup</code>中定义了一个用于处理leader的SyncGroupRequest的回调函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">group synchronized &#123;</span><br><span class="line">  if (group.is(AwaitingSync) &amp;&amp; generationId == group.generationId) &#123;</span><br><span class="line">    if (error != Errors.NONE) &#123;</span><br><span class="line">      resetAndPropagateAssignmentError(group, error)</span><br><span class="line">      maybePrepareRebalance(group)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      setAndPropagateAssignment(group, assignment)</span><br><span class="line">      group.transitionTo(Stable)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为在等待回调函数被执行的过程中，可能会有新的member加入，这样的话就无法保证group的状态以及generation不会变化的。</p>
<h4 id="往replicas写group数据"><a href="#往replicas写group数据" class="headerlink" title="往replicas写group数据"></a><strong>往replicas写group数据</strong></h4><p>调用<code>GroupMetadataManager</code>的store方法，将<strong>DelayedStore</strong>中的messageSet以及回调函数传入到replicaManager的appendMessages方法中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">replicaManager.appendMessages(</span><br><span class="line">  config.offsetCommitTimeoutMs.toLong,</span><br><span class="line">  config.offsetCommitRequiredAcks,</span><br><span class="line">  true, // allow appending to internal offset topic</span><br><span class="line">  delayedStore.messageSet,</span><br><span class="line">  delayedStore.callback)</span><br></pre></td></tr></table></figure></p>
<h3 id="保存offset-commit"><a href="#保存offset-commit" class="headerlink" title="保存offset commit"></a>保存offset commit</h3><p><code>prepareStoreOffsets</code>方法与<code>prepareStoreGroup</code>基本相像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def prepareStoreOffsets(group: GroupMetadata,</span><br><span class="line">                        consumerId: String,</span><br><span class="line">                        generationId: Int,</span><br><span class="line">                        offsetMetadata: immutable.Map[TopicPartition, OffsetAndMetadata],</span><br><span class="line">                        responseCallback: immutable.Map[TopicPartition, Short] =&gt; Unit): Option[DelayedStore]</span><br></pre></td></tr></table></figure></p>
<p>返回的依然是个<strong>DelayedStore</strong>。<br>组装的MessageSet中,key为[groupId, topic, partition]，value为OffsetMetadata，写入的partition由groupId确定。</p>
<h4 id="offsetCommit回调函数"><a href="#offsetCommit回调函数" class="headerlink" title="offsetCommit回调函数"></a><strong>offsetCommit回调函数</strong></h4><blockquote>
<p><code>GroupMetadata</code>为offset commit创建了两个<em>Cache</em>：<code>offsets</code>以及<code>pendingOffsetCommits</code>，consumer提交的offset先存放到pending中，然后根据一定的状态来决定是否移到offsets中。</p>
</blockquote>
<p>如果offsetCommit执行结束后group依旧存活那个根据是否有错误对cache执行不同的操作：</p>
<ol>
<li>没有错误码，那么就将offset写入到<code>offsets</code>中，并从<code>pendingOffsetCommits</code>中移除；</li>
<li>有错误，那么仅仅将offset从<code>pendingOffsetCommits</code>中移除；</li>
</ol>
<h3 id="offset以及group元数据的清理工作"><a href="#offset以及group元数据的清理工作" class="headerlink" title="offset以及group元数据的清理工作"></a>offset以及group元数据的清理工作</h3><p><code>GroupMetadataManager</code>在启动时会开启一个定时执行的清理线程：”delete-expired-group-metadata”，该线程的主要工作是清理<strong>__consumer_offsets</strong>中失效的offset以及可删除的group信息。</p>
<h4 id="remove-expire-offset"><a href="#remove-expire-offset" class="headerlink" title="remove expire offset"></a><strong>remove expire offset</strong></h4><p>每个offset commit提交到server时，都会根据配置的保存时间来设置其失效时间，超过该时间的将会被清除掉。</p>
<p>首先，从cache中筛选出可清楚的offset集合：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val expiredOffsets = offsets.filter &#123;</span><br><span class="line">     case (topicPartition, offset) =&gt; offset.expireTimestamp &lt; startMs &amp;&amp; !pendingOffsetCommits.contains(topicPartition)</span><br><span class="line">   &#125;</span><br><span class="line">   offsets --= expiredOffsets.keySet</span><br><span class="line">   expiredOffsets</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>执行完删除操作过后判断group是否可以判定为<strong>DEAD</strong>：</p>
<ol>
<li>group不包含member</li>
<li>group的两个offsetCache都为空</li>
</ol>
</blockquote>
<h4 id="立墓碑"><a href="#立墓碑" class="headerlink" title="立墓碑"></a><strong>立墓碑</strong></h4><blockquote>
<p>当offset被移除或者group进入<strong>DEAD</strong>状态，都会在__consumer_offsets中留下一个<strong>墓碑</strong>。</p>
</blockquote>
<p>对于group而言：</p>
<ul>
<li><p>如果当前有member存在，那么其存在于__consumer_offsets中的数据是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G6::[G6,Some(consumer),Stable,Map(client1-1ee1d482-c9fa-4617-860a-98d3a3d5a836 -&gt; [client1-1ee1d482-c9fa-4617-860a-98d3a3d5a836,client1,/10.45.48.129,120000])]</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果member为空，但是状态不是<strong>DEAD</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G6::[G6,None,Empty,Map()]</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果group被该清理线程认为<strong>DEAD</strong>，该group信息不仅从<code>groupMetadataCache</code>中移除，还会在__cosnumer_offsets中留下一座墓碑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G6::NULL</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>offset的立墓碑操作与group类似。</p>
<h1 id="consumer与Coordinator的连接过程"><a href="#consumer与Coordinator的连接过程" class="headerlink" title="consumer与Coordinator的连接过程"></a>consumer与Coordinator的连接过程</h1><h2 id="确定coordinator"><a href="#确定coordinator" class="headerlink" title="确定coordinator"></a>确定coordinator</h2><blockquote>
<p>在<a href="http://blog.leanote.com/post/zfb050/Kafka-consumer" target="_blank" rel="noopener">kafka cosumer</a>中提到过consumer寻找coordinator的过程。</p>
</blockquote>
<p>选择将哪个节点作为coordinator其实是由consumer client决定的，确切的说是向已连接的节点中<strong>随机</strong>选择一个最<strong>空闲</strong>的节点发送<code>GroupCoordinatorRequest</code>。(<strong>这里随机是指往一个空闲的随机broker发送请求，收到的response中分配到的coordinator是根据group找对__consumer_offsets对应分区的Leader</strong>)这里空闲的定义是：<em>NetworkClient</em>中处于inflight状态的请求数量少，下面是consumer寻找到coordinator的日志：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[AbstractCoordinator] Sending coordinator request for group G6 to broker 10.45.4.10:9092</span><br><span class="line">[AbstractCoordinator] Received group coordinator response ClientResponse(receivedTimeMs=1495510047579, disconnected=false, request=ClientRequest(callback=..., request=RequestSend(header=&#123;api_key=10,api_version=0,correlation_id=0,client_id=client111&#125;, body=&#123;group_id=G6&#125;), createdTimeMs=1495510047472, sendTimeMs=1495510047577), responseBody=&#123;error_code=0,coordinator=&#123;node_id=1,host=10.45.4.9,port=9092&#125;&#125;)</span><br></pre></td></tr></table></figure></p>
<h3 id="handleGroupCoordinatorRequest"><a href="#handleGroupCoordinatorRequest" class="headerlink" title="handleGroupCoordinatorRequest"></a>handleGroupCoordinatorRequest</h3><p>server在接收到<em>GroupCoordinatorRequest</em>后：</p>
<ul>
<li>根据groupId找到对应__consumer_offsets上的分区<strong>P</strong></li>
<li>找到<strong>P</strong>对应的leader作为coordinator</li>
</ul>
<h2 id="handleJoinGroup"><a href="#handleJoinGroup" class="headerlink" title="handleJoinGroup"></a>handleJoinGroup</h2><h3 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h3><ul>
<li>简单校验：</li>
</ul>
<ol>
<li>coordinator是否处于工作状态</li>
<li>groupId是否有效</li>
<li>coordinator是否负责该group</li>
<li>sessionTimeoutMs是否合理</li>
<li>groupId是否在<code>loadingPartitions</code>中，如果在的话表明正在Rebalance中。</li>
</ol>
<ul>
<li>member校验：<br>客户端<code>ConsumerCoordinator</code>发送的<em>JoinGroupRequest</em> 中的memberId永远都是空的，也就是说memberId是由server端进行设置的。如果Request中group是已知(存在于<code>GroupMetadataManager.groupMetadataCache</code>)的并且memberId非空，那么Server将拒绝这个请求。</li>
</ul>
<h3 id="响应请求"><a href="#响应请求" class="headerlink" title="响应请求"></a>响应请求</h3><blockquote>
<p>group有不同的状态，在不同的状态下有相应的响应joinGroupRequest方法</p>
</blockquote>
<h4 id="Dead"><a href="#Dead" class="headerlink" title="Dead"></a><strong>Dead</strong></h4><p>group处于Dead状态表明该group中没有了成员，并且其GroupMetadata已被该coordinator移除,这个状态下对任何请求都是返回<code>UnknownMemberIdException</code></p>
<h4 id="PreparingRebalance"><a href="#PreparingRebalance" class="headerlink" title="PreparingRebalance"></a><strong>PreparingRebalance</strong></h4><p>根据Request中memberId是否为空有两套处理逻辑：</p>
<ul>
<li><p>memberId为空：执行<code>addMember</code>操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//新建memberId，格式为：clientId-UUID </span><br><span class="line">val memberId = clientId + &quot;-&quot; + group.generateMemberIdSuffix</span><br><span class="line">val member = new MemberMetadata(memberId, group.groupId, clientId, clientHost, rebalanceTimeoutMs,</span><br><span class="line">  sessionTimeoutMs, protocolType, protocols)</span><br><span class="line">member.awaitingJoinCallback = callback</span><br><span class="line">group.add(member.memberId, member)</span><br><span class="line">maybePrepareRebalance(group)</span><br><span class="line">member</span><br></pre></td></tr></table></figure>
</li>
<li><p>memberId不为空：执行<code>updateMember</code>操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">member.supportedProtocols = protocols</span><br><span class="line">member.awaitingJoinCallback = callback</span><br><span class="line">maybePrepareRebalance(group)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>以上两个操作都不会触发<code>PrepareRebalance</code>操作，因为当前已经是PreparingReblance状态了。</p>
</blockquote>
<h4 id="AwaitingSync"><a href="#AwaitingSync" class="headerlink" title="AwaitingSync"></a><strong>AwaitingSync</strong></h4><blockquote>
<p>这个状态表明coordinator已经发送了JoinGroupResponse了，正在等待leader发送分区分配的<strong>SyncGroupRequest</strong>.</p>
</blockquote>
<p>这个时候如果收到一个memberId为空的JoinGroupRequest，表明group中有新的成员加入，除了要创建member信息添加到GroupMetadata中之外，还需要<a href="#PR">prepareRebalance</a>，并将状态重新置为<em>PreparingReblance</em></p>
<p>如果收到的memberId不为空，有两种情况：</p>
<ol>
<li>该成员未收到之前发送过的JoinGroupResponse，这种情况就重新发送一个Response，leader和member分配不会改变的</li>
<li>这次的Request中改变了分区分配策略，因此需要执行<code>updateMember</code>操作，并且还需要执行<code>PrepareRebalance</code>操作将状态重新置为<em>PreparingReblance</em>。</li>
</ol>
<h4 id="Empty-or-Stable"><a href="#Empty-or-Stable" class="headerlink" title="Empty or Stable"></a><strong>Empty or Stable</strong></h4><p>处理三种可能的joinGroup情形：</p>
<ol>
<li>收到memberId为空的请求，group有新成员加入，执行<code>addMember</code>以及<code>PrepareRebalce</code>操作。</li>
<li>收到leader的joinGroup请求或者请求中的分配策略发生变化(<em>何种场景下会leader会重发joinGroup请求嘞？<a href="#rejoin">分区变化时consumer是如何rejoin的</a></em>)</li>
<li>其他情况(followers发送的没有内容变化的Join请求)说明followers可能没收到Response，因此重发Response。</li>
</ol>
<h2 id="handleSyncGroup"><a href="#handleSyncGroup" class="headerlink" title="handleSyncGroup"></a>handleSyncGroup</h2><p>在校验阶段如果发现该coordinator并不负责该group，则会反馈<code>NotCoordinatorForGroupException</code>。</p>
<p>能够正常响应SyncGroup请求的group状态为<strong>AwaitingSync</strong>和<strong>Stable</strong>，其中<strong>AwaitingSync</strong>状态下就是执行<a href="#storeGroup">保存group数据</a></p>
<h2 id="handleLeaveGroup"><a href="#handleLeaveGroup" class="headerlink" title="handleLeaveGroup"></a>handleLeaveGroup</h2><p>主要有三步操作</p>
<h3 id="1、从心跳DOP中移除"><a href="#1、从心跳DOP中移除" class="headerlink" title="1、从心跳DOP中移除"></a>1、从心跳<strong>DOP</strong>中移除</h3><p>心跳DOP(heartbeatPurgatory)中保存的是<strong>DelayedHeartbeat</strong>，该<strong>DO</strong>操作用于侦测member是否存活,成员变量包括group、member已经超时时间。当member要离开group时需要将该member对应的<br><strong>DO</strong>操作完成并移除掉。</p>
<h3 id="2、从group中移除"><a href="#2、从group中移除" class="headerlink" title="2、从group中移除"></a>2、从group中移除</h3><p>将member从其对应的<code>GroupMetadata</code>中的<em>members</em>中移除，然后根据当前group状态进行对应的处理：</p>
<ul>
<li><strong>Stable</strong> or <strong>Empty</strong>：触发<strong>PrepareRebalance</strong></li>
<li><strong>PreparingRebalance</strong>：complete掉joinPurgatory中该group的<strong>DJ</strong>操作</li>
</ul>
<h3 id="3、组装反馈信息"><a href="#3、组装反馈信息" class="headerlink" title="3、组装反馈信息"></a>3、组装反馈信息</h3><p>其实consumer对LeaveGroupResponse不是很关心，因为不会重发。</p>
<h2 id="handleFetchOffsets"><a href="#handleFetchOffsets" class="headerlink" title="handleFetchOffsets"></a>handleFetchOffsets</h2><p>consumer是从coordinator维护的offset cache ：<code>offsets</code>中获取group已提交的offset信息的。</p>
<p><code>FetchRequest</code>中包含group以及topic-partition信息，据此coordinator进行反馈：</p>
<ul>
<li>如果group不存在 <em>or</em> group状态为<strong>DEAD</strong>，则返回的<code>PartitionData</code>中offset为-1(代表<strong>InvalidOffset</strong>)</li>
<li>如果未指定topic以及partition，那么就将<code>offsets</code>中所有的[topic-partition, commit offset]数据都反馈给consunmer</li>
<li>如果指定topic-partition，就将<code>offsets</code>中对应的数据反馈，找不到就反馈-1</li>
</ul>
<hr>
<h1 id="Helper"><a href="#Helper" class="headerlink" title="Helper"></a>Helper</h1><h2 id="分区变化时consumer是如何rejoin的？"><a href="#分区变化时consumer是如何rejoin的？" class="headerlink" title="分区变化时consumer是如何rejoin的？"></a><span id="rejoin">分区变化时consumer是如何rejoin的？</span></h2><p>消费者在长连接的时候，增加了分区的topic，client是如何感知到的呢，下面是实验过程记录：</p>
<ul>
<li><p>10:33:08 开启consumer</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[AbstractCoordinator] Sending coordinator request for group G6 to broker 10.45.4.10:9092 (id: -2 rack: null)</span><br><span class="line">[AbstractCoordinator] Discovered coordinator 10.45.4.9:9092 (id: 2147483646 rack: null) for group G6.</span><br><span class="line">[ConsumerCoordinator] Revoking previously assigned partitions [] for group G6</span><br><span class="line">[ConcurrentMessageListenerContainer] partitions revoked:[]</span><br><span class="line">[AbstractCoordinator] (Re-)joining group G6</span><br><span class="line">[AbstractCoordinator] Sending JoinGroup (&#123;group_id=G6,session_timeout=120000,member_id=,protocol_type=consumer,group_protocols=[&#123;protocol_name=range,protocol_metadata=java.nio.HeapByteBuffer[pos=0 lim=18 cap=18]&#125;]&#125;) to coordinator 10.45.4.9:9092 (id: 2147483646 rack: null)</span><br><span class="line">[AbstractCoordinator] Received successful join group response for group G6: </span><br><span class="line">[AbstractCoordinator] Successfully joined group G6 with generation 5</span><br><span class="line">[ConcurrentMessageListenerContainer] partitions assigned:[newOne-8, newOne-4, newOne-5, newOne-6, newOne-7, newOne-0, newOne-1, newOne-2, newOne-3]</span><br></pre></td></tr></table></figure>
</li>
<li><p>10:34:17 controller检测到partitoin变化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[AddPartitionsListener on 2]: Partition modification triggered &#123;&quot;version&quot;:1,&quot;partitions&quot;:&#123;&quot;8&quot;:[2,1],&quot;4&quot;:[1,3],&quot;11&quot;:[2,1],&quot;9&quot;:[3,2],&quot;5&quot;:[2,1],&quot;10&quot;:[1,3],&quot;6&quot;:[3,2],&quot;1&quot;:[1,2],&quot;0&quot;:[3,1],&quot;2&quot;:[2,3],&quot;7&quot;:[1,3],&quot;3&quot;:[3,2]&#125;&#125; for path /brokers/topics/newOne (kafka.controller.PartitionStateMachine$PartitionModificationsListener)</span><br></pre></td></tr></table></figure>
</li>
<li><p>10:38:10 client rejoin</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[ConsumerCoordinator] Revoking previously assigned partitions [newOne-8, newOne-4, newOne-5, newOne-6, newOne-7, newOne-0, newOne-1, newOne-2, newOne-3] for group G6</span><br><span class="line">[ConcurrentMessageListenerContainer] partitions revoked:[newOne-8, newOne-4, newOne-5, newOne-6, newOne-7, newOne-0, newOne-1, newOne-2, newOne-3]</span><br><span class="line">[AbstractCoordinator] &quot;(Re-)joining group G6&quot;</span><br><span class="line">[AbstractCoordinator] Sending JoinGroup (&#123;group_id=G6,session_timeout=120000,member_id=client111-39aa3f5d-cdf2-492f-bf41-4affe1a00421,protocol_type=consumer,group_protocols=[&#123;protocol_name=range,protocol_metadata=java.nio.HeapByteBuffer[pos=0 lim=18 cap=18]&#125;]&#125;) to coordinator 10.45.4.9:9092 (id: 2147483646 rack: null)</span><br><span class="line">[AbstractCoordinator] Received successful join group response for group G6: &#123;error_code=0,generation_id=6,group_protocol=range,leader_id=client111-39aa3f5d-cdf2-492f-bf41-4affe1a00421,member_id=client111-39aa3f5d-cdf2-492f-bf41-4affe1a00421,members=[&#123;member_id=client111-39aa3f5d-cdf2-492f-bf41-4affe1a00421,member_metadata=java.nio.HeapByteBuffer[pos=0 lim=18 cap=18]&#125;]&#125;</span><br><span class="line">[AbstractCoordinator] Sending leader SyncGroup for group G6 to coordinator 10.45.4.9:9092 (id: 2147483646 rack: null): &#123;group_id=G6,generation_id=6,member_id=client111-39aa3f5d-cdf2-492f-bf41-4affe1a00421,group_assignment=[&#123;member_id=client111-39aa3f5d-cdf2-492f-bf41-4affe1a00421,member_assignment=java.nio.HeapByteBuffer[pos=0 lim=70 cap=70]&#125;]&#125;</span><br><span class="line">[AbstractCoordinator] Successfully joined group G6 with generation 6</span><br><span class="line">[ConsumerCoordinator] Setting newly assigned partitions [newOne-8, newOne-9, newOne-10, newOne-11, newOne-4, newOne-5, newOne-6, newOne-7, newOne-0, newOne-1, newOne-2, newOne-3] for group G6</span><br><span class="line">[ConcurrentMessageListenerContainer] partitions assigned:[newOne-8, newOne-9, newOne-10, newOne-11, newOne-4, newOne-5, newOne-6, newOne-7, newOne-0, newOne-1, newOne-2, newOne-3]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>那么consumer到底是如何触发rejoin的呢，这个时间间隔有何讲究？</p>
</blockquote>
<p>一开始自己关注的点是<code>rejoinNeeded</code>什么时候被置为true<br><img src="http://olt6kofv9.bkt.clouddn.com/17-5-25/78440956.jpg" alt=""></p>
<p>有三种情况下会被置为true：</p>
<ol>
<li>SyncGroupResponse中存在ERROR</li>
<li>HeartbeatResponse中存在REBALANCE_IN_PROGRESS、ILLEGAL_GENERATION或UNKNOWN_MEMBER_ID的ERROR</li>
<li>consumer leave group</li>
</ol>
<p>然而从日志来看并没有出现错误，所以注意力转移到<code>needRejoin</code>方法中的其他判断条件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">return subscriptions.partitionsAutoAssigned() &amp;&amp;</span><br><span class="line">        (super.needRejoin() || subscriptions.partitionAssignmentNeeded());</span><br></pre></td></tr></table></figure></p>
<p>partitionsAutoAssigned的条件是一直满足的，<code>partitionAssignmentNeeded</code>被置为true的场景有点多，排查起来比较费时费力。这时有个新的现象进入眼帘：<strong>经过多次试验后发现rejoin距离分区调整的时间间隔最长不超过5分钟！</strong>。而<code>metadata.max.age.ms</code>这个配置参数的默认值刚好是5分钟：<br><img src="http://olt6kofv9.bkt.clouddn.com/17-5-25/33077532.jpg" alt=""></p>
<p>该配置项是client端强制刷新metadata的最长时间间隔。</p>
<blockquote>
<p>因为kafka集群出现broker或者partition变化的时候是不会通知客户端的，因此客户端需要定期的去获取metadata的值。</p>
</blockquote>
<p>客户端判断是否需要刷新metadata的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public synchronized long timeToNextUpdate(long nowMs) &#123;</span><br><span class="line">    long timeToExpire = needUpdate ? 0 : Math.max(this.lastSuccessfulRefreshMs + this.metadataExpireMs - nowMs, 0);</span><br><span class="line">    long timeToAllowUpdate = this.lastRefreshMs + this.refreshBackoffMs - nowMs;</span><br><span class="line">    return Math.max(timeToExpire, timeToAllowUpdate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中metadataExpireMs就是5分钟【默认】。</p>
<p>ConsumerCoordinator为metadata添加了一个Listener监听其更新操作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addMetadataListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.metadata.addListener(<span class="keyword">new</span> Metadata.Listener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMetadataUpdate</span><span class="params">(Cluster cluster)</span> </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// check if there are any changes to the metadata which should trigger a rebalance</span></span><br><span class="line">            <span class="keyword">if</span> (subscriptions.partitionsAutoAssigned()) &#123;</span><br><span class="line">                MetadataSnapshot snapshot = <span class="keyword">new</span> MetadataSnapshot(subscriptions, cluster);</span><br><span class="line">                <span class="keyword">if</span> (!snapshot.equals(metadataSnapshot)) &#123;</span><br><span class="line">                    metadataSnapshot = snapshot;</span><br><span class="line">                    subscriptions.needReassignment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>needReassignment()</code>方法将<code>needsPartitionAssignment</code>置为true,这正是<code>partitionAssignmentNeeded()</code>方法所需要的。</p>
<h2 id="how-to-prepare-rebalance"><a href="#how-to-prepare-rebalance" class="headerlink" title=" how to prepare rebalance"></a><span id="PR"> how to prepare rebalance</span></h2><blockquote>
<p>在<a href="http://blog.leanote.com/post/zfb050/Kafka-consumer" target="_blank" rel="noopener">kafka cosumer</a>中做个一个实验：consumer多次关闭重连后，partition将会在较长时间后才能分配到。GroupCoordinator做了什么才导致这样的现象发生嘞？</p>
</blockquote>
<p><code>prepareReblance</code>的代码不长，但是要搞懂到底做了些什么着实不易：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private def prepareRebalance(group: GroupMetadata) &#123;</span><br><span class="line">  // if any members are awaiting sync, cancel their request and have them rejoin</span><br><span class="line">  if (group.is(AwaitingSync))</span><br><span class="line">    resetAndPropagateAssignmentError(group, Errors.REBALANCE_IN_PROGRESS)</span><br><span class="line"></span><br><span class="line">  group.transitionTo(PreparingRebalance)</span><br><span class="line">  info(&quot;Preparing to restabilize group %s with old generation %s&quot;.format(group.groupId, group.generationId))</span><br><span class="line"></span><br><span class="line">  val rebalanceTimeout = group.rebalanceTimeoutMs</span><br><span class="line">  val delayedRebalance = new DelayedJoin(this, group, rebalanceTimeout)</span><br><span class="line">  val groupKey = GroupKey(group.groupId)</span><br><span class="line">  joinPurgatory.tryCompleteElseWatch(delayedRebalance, Seq(groupKey))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="DelayedOperation-And-DelayedOperationPurgatory"><a href="#DelayedOperation-And-DelayedOperationPurgatory" class="headerlink" title="DelayedOperation And DelayedOperationPurgatory"></a>DelayedOperation And DelayedOperationPurgatory</h3><p><a href="https://cwiki.apache.org/confluence/display/KAFKA/Purgatory+Redesign+Proposal" target="_blank" rel="noopener">purgatory wiki</a></p>
<blockquote>
<p><strong>DelayedJoin</strong>(简称<strong>DJ</strong>)是<strong>DelayedOperation</strong>(简称<strong>DO</strong>)的子类，<strong>DelayedOperationPurgatory</strong>(简称<strong>DOP</strong>)用于记录<strong>DO</strong>，并将超时的<strong>DO</strong>执行expired操作?</p>
</blockquote>
<p><strong>DO</strong>用于执行延迟任务，参数只有一个超时时间，目前已有的实现类有：<br><img src="http://olt6kofv9.bkt.clouddn.com/17-5-25/40124304.jpg" alt=""></p>
<p>比如<strong>DelayedFetch</strong>的操作允许Fetch等待一定数量的消息或者达到超时时间后再返回。</p>
<ul>
<li>当<strong>DO</strong>完成给定的操作后，会调用<code>onComplete</code>方法(该方法需要子类实现)并且只会被调用一次, <code>isComplete</code>方法将返回true(通过原子变量<code>AtomicBoolean</code>实现)；</li>
<li><code>forceComplete</code>和<code>tryComplete</code>方法等能触发<code>onComplete</code>，其中前者已经在<strong>DO</strong>中实现了：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def forceComplete(): Boolean = &#123;</span><br><span class="line">  if (completed.compareAndSet(false, true)) &#123;</span><br><span class="line">    // cancel the timeout timer</span><br><span class="line">    cancel()</span><br><span class="line">    onComplete()</span><br><span class="line">    true</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>该方法将原子变量强行换成true(如果当前为false的话)，然后调用<code>onComplete</code>操作；后者需要子类实现：在判断是否达到complete条件后再调用forceComplete。</p>
<ul>
<li><p><code>safeTryComplete</code>是<code>TryComplete</code>的线程安全版：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def safeTryComplete(): Boolean = &#123;</span><br><span class="line">  synchronized &#123;</span><br><span class="line">    tryComplete()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果<strong>DO</strong>超时，将调用<code>onExpiration</code>操作(0.10.1.1版本中，<strong>DJ</strong>仍未实现该方法)</p>
</li>
</ul>
<h4 id="Watchers"><a href="#Watchers" class="headerlink" title="Watchers"></a><strong>Watchers</strong></h4><p><strong>DOP</strong>形象的定义了<code>Watchers</code>这个类用于存放和“观察”<strong>DO</strong>，使用到的数据结构是<code>ConcurrentLinkedQueue</code>。</p>
<ul>
<li><code>watch</code>：该方法将<strong>DO</strong>添加到队列中</li>
<li><code>tryComplteWatched</code>：遍历队列，将已完成的<strong>DO</strong>从队列中移除，调用未完成<strong>DO</strong>的<code>safeTryComplte</code>方法，并记录在该方法中完成的<strong>DO</strong>数量。</li>
<li><code>purgeCompleted</code>：该方法只是将已完成的移除掉，并返回移除的数量。</li>
<li>每个Watchers都与一些<strong>key</strong>关联(<code>HashMap</code>)，定义为<em>watchersForKey</em><ul>
<li>Key的类型没有限制，</li>
<li>当key对应的DO全部完成后，key以及对应的Watchers一起从Map中移除。</li>
</ul>
</li>
</ul>
<p><img src="http://olt6kofv9.bkt.clouddn.com/18-3-26/38785112.jpg" alt=""></p>
<h4 id="其他参数及属性"><a href="#其他参数及属性" class="headerlink" title="其他参数及属性"></a><strong>其他参数及属性</strong></h4><ul>
<li>timeoutTimer</li>
<li>brokerId</li>
<li>purgeInterval：清理基准线，当<strong>DOP</strong>中已完成的<strong>DO</strong>数量达到该基准线后开始清理操作</li>
<li>reaperenbaled：是否允许清除<strong>DO</strong></li>
<li>watchersForKey：存放watcher与对应的key</li>
<li>expirationReaper：超时<strong>DO</strong>清道夫</li>
</ul>
<h4 id="tryCompleteElseWatch"><a href="#tryCompleteElseWatch" class="headerlink" title="tryCompleteElseWatch"></a><strong>tryCompleteElseWatch</strong></h4><p>该方法将一个<strong>DO</strong>塞进Watchers中并与多个Key进行关联。如果每次与Key进行关联时都执行一次<code>tryComplete</code>操作成本很大。kafka选择了一个折中的策略，保证在该方法内最多调用两次<code>tryComplete</code>方法：</p>
<ol>
<li>执行第一次<code>tryComplete</code>操作，成功就返回</li>
<li>遍历keys，如果<strong>DO</strong>未完成就将key与Watchers进行绑定，添加到<code>watchersForKey</code></li>
<li>执行第二次<code>tryComplete</code>，成功就返回</li>
<li>依然未成功的话就添加到<code>timeoutTimer</code>中<br>(进入这里面的<strong>DO</strong>将怎么处理？怎么才能再次触发<code>onComplete</code>操作呢？)<ul>
<li>放到<code>Timer</code>中的<strong>DO</strong>在超时的时候会执行<code>TimerTask#run()</code>方法</li>
<li><code>DelayedOperation</code>基础了<code>TimerTask</code>类，覆盖了父类的run方法：<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="keyword">if</span> (forceComplete())</span><br><span class="line">    onExpiration()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h3 id="DelayedJoin"><a href="#DelayedJoin" class="headerlink" title="DelayedJoin"></a>DelayedJoin</h3><p>GroupCoordinator中实现了<strong>DJ</strong>作为<strong>DO</strong>的各个方法，在分析这些方法前需要关注的是<em>GroupMetadata</em> 与 <em>MemberMetadata</em>的两个属性：</p>
<h4 id="notYetRejoinedMembers-AND-awaitingJoinCallback"><a href="#notYetRejoinedMembers-AND-awaitingJoinCallback" class="headerlink" title="notYetRejoinedMembers AND awaitingJoinCallback"></a><strong>notYetRejoinedMembers AND awaitingJoinCallback</strong></h4><ul>
<li><code>awaitingJoinCallback</code>是Mebmer的属性，初始为null;当member所在的group处于<code>PreparingReblance</code>状态下，member向coordinator发送了JoinGroup请求，那么该字段用于存放将<strong>JoinGroupResult</strong>反馈的回调方法，在重平衡结束后或者coordinator执行<strong>出境</strong>操作等会将该字段重新置为Null</li>
<li><code>notYetRejoinedMembers</code>存放该group中没有<code>awaitingJoinCallback</code>的member，在Rebalance期间，该集合中存储的是那些没有发送JoinGroup请求的member。</li>
</ul>
<h4 id="tryComplete"><a href="#tryComplete" class="headerlink" title="tryComplete"></a><strong>tryComplete</strong></h4><p>如果group中所有的成员都发送了<em>JoinGroupRequest</em> 就调用forceComplete方法(<strong>DO</strong>中的方法)：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tryCompleteJoin</span></span>(group: <span class="type">GroupMetadata</span>, forceComplete: () =&gt; <span class="type">Boolean</span>) = &#123;</span><br><span class="line">  group synchronized &#123;</span><br><span class="line">    <span class="keyword">if</span> (group.notYetRejoinedMembers.isEmpty)</span><br><span class="line">      forceComplete()</span><br><span class="line">    <span class="keyword">else</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>留个问题</strong> 如果某个member迟迟不发送JoinGroup请求的话，那总不能永久等待吧？member在什么情况下会被移出group呢？(关键点在于<strong>DelayedHeartbeat的onExpireHeartbeat方法</strong>)</p>
<h4 id="onExpireHeartbeat"><a href="#onExpireHeartbeat" class="headerlink" title="onExpireHeartbeat"></a><strong>onExpireHeartbeat</strong></h4><p>如果coordinator听不到member的心跳：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">member.latestHeartbeat + member.sessionTimeoutMs &gt; heartbeatDeadline</span><br></pre></td></tr></table></figure></p>
<p>heartbeat的超时时间由consumer的<code>session.timeout.ms</code>控制【默认为100s】<br>那么就会将member从group中移除：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">onMemberFailure</span></span>(group: <span class="type">GroupMetadata</span>, member: <span class="type">MemberMetadata</span>) &#123;</span><br><span class="line">  trace(<span class="string">"Member %s in group %s has failed"</span>.format(member.memberId, group.groupId))</span><br><span class="line">  group.remove(member.memberId)</span><br><span class="line">  group.currentState <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Dead</span> | <span class="type">Empty</span> =&gt;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Stable</span> | <span class="type">AwaitingSync</span> =&gt; maybePrepareRebalance(group)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">PreparingRebalance</span> =&gt; joinPurgatory.checkAndComplete(<span class="type">GroupKey</span>(group.groupId))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果当前group处于<code>PreparingRebalance</code>状态，那么将会将查下是否可以complete join操作。那么前面两个问题已经明朗了：</p>
<ol>
<li>添加到<strong>DOP</strong>的timeoutTimer中的<strong>DO</strong>只是放入一个定时器内，超时后移除，<strong>DO</strong>能否在超时前执行<code>onComplete</code>操作完全靠外部触发；</li>
<li>如果某个group存在多个member，如果其中存在member非正常退出(<em>即没有执行unsubscribe操作</em>)，那么coordinator必须依赖心跳超时来检查该member是否dead，在此期间内的joinGroup请求无法立即得到响应。</li>
</ol>
<h4 id="onCompleteJoin"><a href="#onCompleteJoin" class="headerlink" title="onCompleteJoin"></a><strong>onCompleteJoin</strong></h4><p><strong>疑惑</strong> 该方法的第一步看不懂：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// remove any members who haven't joined the group yet</span></span><br><span class="line">group.notYetRejoinedMembers.foreach &#123; failedMember =&gt;</span><br><span class="line">  group.remove(failedMember.memberId)</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> cut the socket connection to the client</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>能够执行<code>onCompleteJoin</code>说明<code>notYetRejoinedMembers</code>已经是空的了，这里的移除操作感觉多余了？？？？</p>
<p><strong>JoinGroupResult</strong>：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> joinResult = <span class="type">JoinGroupResult</span>(</span><br><span class="line">  members=<span class="keyword">if</span> (member.memberId == group.leaderId) &#123; group.currentMemberMetadata &#125; <span class="keyword">else</span> &#123; <span class="type">Map</span>.empty &#125;,</span><br><span class="line">  memberId=member.memberId,</span><br><span class="line">  generationId=group.generationId,</span><br><span class="line">  subProtocol=group.protocol,</span><br><span class="line">  leaderId=group.leaderId,</span><br><span class="line">  errorCode=<span class="type">Errors</span>.<span class="type">NONE</span>.code)</span><br></pre></td></tr></table></figure></p>
<p>group的leaderId采取先来后到的原则，新来的memberId作为leaderId。</p>
<p>对于非正常重启一个consumer所遇到的长时间等待可以用下图加深理解：</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Kafka/" rel="tag"># Kafka</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/04/04/test-blog/" rel="next" title="test_blog">
                <i class="fa fa-chevron-left"></i> test_blog
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zNTQ1NC8xMTk5MA"></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#GroupCoordinator"><span class="nav-number">1.</span> <span class="nav-text">GroupCoordinator</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#GroupMetadataManager"><span class="nav-number">1.1.</span> <span class="nav-text">GroupMetadataManager</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#consumer-offsets"><span class="nav-number">1.1.1.</span> <span class="nav-text">__consumer_offsets</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#小实验"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">小实验</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#保存group元数据"><span class="nav-number">1.1.2.</span> <span class="nav-text">保存group元数据</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#生成消息"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">生成消息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#设置appendLog回调函数"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">设置appendLog回调函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#执行storeGroup回调函数"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">执行storeGroup回调函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#往replicas写group数据"><span class="nav-number">1.1.2.4.</span> <span class="nav-text">往replicas写group数据</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#保存offset-commit"><span class="nav-number">1.1.3.</span> <span class="nav-text">保存offset commit</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#offsetCommit回调函数"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">offsetCommit回调函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#offset以及group元数据的清理工作"><span class="nav-number">1.1.4.</span> <span class="nav-text">offset以及group元数据的清理工作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#remove-expire-offset"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">remove expire offset</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#立墓碑"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">立墓碑</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#consumer与Coordinator的连接过程"><span class="nav-number">2.</span> <span class="nav-text">consumer与Coordinator的连接过程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#确定coordinator"><span class="nav-number">2.1.</span> <span class="nav-text">确定coordinator</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#handleGroupCoordinatorRequest"><span class="nav-number">2.1.1.</span> <span class="nav-text">handleGroupCoordinatorRequest</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#handleJoinGroup"><span class="nav-number">2.2.</span> <span class="nav-text">handleJoinGroup</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#校验"><span class="nav-number">2.2.1.</span> <span class="nav-text">校验</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#响应请求"><span class="nav-number">2.2.2.</span> <span class="nav-text">响应请求</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Dead"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">Dead</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PreparingRebalance"><span class="nav-number">2.2.2.2.</span> <span class="nav-text">PreparingRebalance</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AwaitingSync"><span class="nav-number">2.2.2.3.</span> <span class="nav-text">AwaitingSync</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Empty-or-Stable"><span class="nav-number">2.2.2.4.</span> <span class="nav-text">Empty or Stable</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#handleSyncGroup"><span class="nav-number">2.3.</span> <span class="nav-text">handleSyncGroup</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#handleLeaveGroup"><span class="nav-number">2.4.</span> <span class="nav-text">handleLeaveGroup</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、从心跳DOP中移除"><span class="nav-number">2.4.1.</span> <span class="nav-text">1、从心跳DOP中移除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、从group中移除"><span class="nav-number">2.4.2.</span> <span class="nav-text">2、从group中移除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、组装反馈信息"><span class="nav-number">2.4.3.</span> <span class="nav-text">3、组装反馈信息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#handleFetchOffsets"><span class="nav-number">2.5.</span> <span class="nav-text">handleFetchOffsets</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Helper"><span class="nav-number">3.</span> <span class="nav-text">Helper</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#分区变化时consumer是如何rejoin的？"><span class="nav-number">3.1.</span> <span class="nav-text">分区变化时consumer是如何rejoin的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#how-to-prepare-rebalance"><span class="nav-number">3.2.</span> <span class="nav-text"> how to prepare rebalance</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DelayedOperation-And-DelayedOperationPurgatory"><span class="nav-number">3.2.1.</span> <span class="nav-text">DelayedOperation And DelayedOperationPurgatory</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Watchers"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">Watchers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其他参数及属性"><span class="nav-number">3.2.1.2.</span> <span class="nav-text">其他参数及属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tryCompleteElseWatch"><span class="nav-number">3.2.1.3.</span> <span class="nav-text">tryCompleteElseWatch</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DelayedJoin"><span class="nav-number">3.2.2.</span> <span class="nav-text">DelayedJoin</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#notYetRejoinedMembers-AND-awaitingJoinCallback"><span class="nav-number">3.2.2.1.</span> <span class="nav-text">notYetRejoinedMembers AND awaitingJoinCallback</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tryComplete"><span class="nav-number">3.2.2.2.</span> <span class="nav-text">tryComplete</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#onExpireHeartbeat"><span class="nav-number">3.2.2.3.</span> <span class="nav-text">onExpireHeartbeat</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#onCompleteJoin"><span class="nav-number">3.2.2.4.</span> <span class="nav-text">onCompleteJoin</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  







  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/canvas_lines.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("cea0JXdngKbekqyUcytEll8T-gzGzoHsz", "4K0JxrNpvBK8dDrqbkSm4axL");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
